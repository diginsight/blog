[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To Diginsight Blog",
    "section": "",
    "text": "Welcome! This is the first post in a Diginsight blog. \nhere, we’ll discuss and illustrate diginsight components and samples implementation.\nor any interesting thing we’ll come across while working with diginsight"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Diginsight blog",
    "section": "",
    "text": "Welcome To Diginsight Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nAug 25, 2024\n\n\nDario Airoldi\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/20240917 - Steps to add diginsight to DS.DevopsHelper.Api/index.html",
    "href": "posts/20240917 - Steps to add diginsight to DS.DevopsHelper.Api/index.html",
    "title": "Steps to add diginsight to DS.DevopsHelper.Api",
    "section": "",
    "text": "today I worked with some friends to a .net API and I wanted to have it instrumented with diginsight.\n\n\n\nDevopsHelper API project\n\n\nbelow the basic steps I followed to integrate text based streams on Log4Net and the appservice Console.\n\nSTEP01: Add references to diginsight packages\nI start adding the following 3 references:\n&lt;PackageReference Include=\"Diginsight.AspnetCore\" Version=\"3.0.0-alpha.203\" /&gt;\n&lt;PackageReference Include=\"Diginsight.Diagnostics\" Version=\"3.0.0-alpha.203\" /&gt;\n&lt;PackageReference Include=\"Diginsight.Diagnostics.Log4Net\" Version=\"3.0.0-alpha.203\" /&gt;\nwhere: - Diginsight.Diagnostics is the core engine for application flow rendering - Diginsight.Diagnostics.Log4Net integrates Log4Net file logs - Diginsight.AspnetCore allows support for Dynamic Logging and Dynamic Configuration.\n\n\n\nalt text\n\n\n\n\nSTEP02: Add the Observability ActivitySource to your projects\nSystem Diagnostics emits telemetry by means of ActivitySource classes.\nIn our solution we’ll choose to use one ActivitySource class for every project:\ninternal static class Observability\n{\n    public static readonly ActivitySource ActivitySource = new(Assembly.GetExecutingAssembly().GetName().Name!);\n}\n\n\n\nalt text\n\n\n\n\nSTEP03: Configure the startup sequence\nHere we’ll configure the Log4Net file stream logger and the Console logger. Also, we’ll add logging to the startup sequence itself by means of the DeferredLoggerFactory.   In particular, the DeferredLoggerFactory: - gathers the execution flow until the the standard logging system is setup. - Flushes recorded telemetry to standard ILogger&lt;&gt; system, as soon as possible, upon services creation.\nhere we create the deferred logger factory at application startup:\npublic static IDeferredLoggerFactory LoggerFactory;\n\nstatic Program()\n{\n    DiginsightActivitiesOptions activitiesOptions = new() { LogActivities = true };\n    IDeferredLoggerFactory deferredLoggerFactory = new DeferredLoggerFactory(activitiesOptions: activitiesOptions);\n    deferredLoggerFactory.ActivitySources.Add(Observability.ActivitySource);\n    LoggerFactory = deferredLoggerFactory;\n}\nhere we use the deferred logger factory to create Ilogger for for the startup sequence:\npublic static void Main(string[] args)\n{\n    ILogger logger = LoggerFactory.CreateLogger(typeof(Program));\n\n    var app = default(WebApplication);\n    using (var activity = Observability.ActivitySource.StartMethodActivity(logger, new { args }))\n    {\n        var builder = WebApplication.CreateBuilder(args); logger.LogDebug(\"builder = WebApplication.CreateBuilder(args);\");\n        builder.Host.ConfigureAppConfigurationNH(); logger.LogDebug(\"builder.Host.ConfigureAppConfigurationNH();\");\n        builder.Services.AddObservability(builder.Configuration);     // Diginsight: registers loggers\n        builder.Services.FlushOnCreateServiceProvider(LoggerFactory); // Diginsight: registers startup log flush\n\n        //...\n        //... register services \n        //...\n\n        var webHost = builder.Host.UseDiginsightServiceProvider(); // Diginsight: Flushes startup log and initializes standard log\n        app = builder.Build(); logger.LogDebug(\"app = builder.Build();\");\n\n        logger.LogInformation(\"Configure the HTTP request pipeline.\");\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseSwagger();\n            app.UseSwaggerUI(c =&gt;\n            {\n                c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"KnowledgeAPI v1\");\n                c.OAuthClientId(azureAd.ClientId);\n                c.OAuthUsePkce();\n                c.OAuthScopeSeparator(\" \");\n            });\n        }\n\n        app.UseHttpsRedirection();\n\n        app.UseAuthorization();\n\n        app.MapControllers();\n    }\n\n    app.Run();\n}\nplease note that: - builder.Services.AddObservability(builder.Configuration); registers loggers for Log4net and the application Console - builder.Services.FlushOnCreateServiceProvider(LoggerFactory); registers startup log flush that will happen upon builder.Build() - var webHost = builder.Host.UseDiginsightServiceProvider(); registers a service provider that manages deferred log flush with services creation.\n\n\nSTEP04: add Instrumentation log to methods and return values\nwe are now ready to add automatic instrumentation to methods and return values:\nhere is an example method start\n[HttpGet(\"SendApprovalNotifications\")]\npublic async Task&lt;IActionResult&gt; SendApprovalNotificationsAsync(int buildId)\n{\n    using var activity = Observability.ActivitySource.StartMethodActivity(logger, new { buildId });\nhere is an example method completion where the result value is added to the method closing row:\n    activity?.SetOutput(ret);\n    return ret;\n}\n\n\n\nalt text\n\n\nhere is the resulting flow for an API call:"
  }
]